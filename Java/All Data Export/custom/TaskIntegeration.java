/*
  This class has been generated by the Code Generator
*/

package com.monster.npd.submission.custom;

import java.io.File;
import java.io.FileOutputStream;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.CellStyle;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.xssf.usermodel.XSSFCellStyle;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

import com.cordys.cpc.bsf.busobject.BusObjectConfig;
import com.cordys.cpc.bsf.busobject.BusObjectIterator;
import com.eibus.util.logger.CordysLogger;
import com.monster.npd.submission.util.ConstantVariablesEnum;
import com.monster.npd.submission.util.EnumColumnMapper;
import com.monster.npd.submission.util.EnumGovernanceMileStoneMapper;
import com.monster.npd.submission.util.EnumTaskColumnMapper;
import com.monster.npd.submission.util.Util;
import com.monster.npd.submission.util.TasksEnum;

public class TaskIntegeration extends TaskIntegerationBase {
	private static CordysLogger logger = CordysLogger.getCordysLogger(TaskIntegeration.class);

	public TaskIntegeration() {
		this((BusObjectConfig) null);
	}

	public TaskIntegeration(BusObjectConfig config) {
		super(config);
	}

	/**
	 * @author AvinashRavat
	 * @param filePath
	 * @param fileGUID
	 * @param fileName
	 * @param cursor
	 * @return This Service will integrate Projects and Project related MileStones
	 *         and Tasks. After creating and writing Excel it will return that excel
	 *         file Path
	 */

	static int totalProjectCount = 0;
	static int oneTimeProjectCount = Integer
			.parseInt(com.eibus.util.system.EIBProperties.getProperty("com.monster.npd.export.noOfProject"));
	static String sheetName = com.eibus.util.system.EIBProperties.getProperty("com.monster.npd.export.sheetName");
	static String requestIDEnum = ConstantVariablesEnum.requestId.getValue();
	static String divisionEnum = ConstantVariablesEnum.division.getValue();
	static String taskNameEnum = ConstantVariablesEnum.taskName.getValue();
	static String stage = ConstantVariablesEnum.stage.getValue();
	static String task13 = ConstantVariablesEnum.task13.getValue();
	static String task13A = ConstantVariablesEnum.task13A.getValue();
	static String divisionValue = "";

	public static String generateExcelWithTask(String filePath, String fileName, int id,
			com.cordys.cpc.bsf.query.Cursor cursor) {
		String fileCheckPath = "";
		try {

			// new Workbook
			XSSFWorkbook workbook = new XSSFWorkbook();
			XSSFSheet sheet = workbook.createSheet(sheetName);
			XSSFCellStyle wraptextStyle = workbook.createCellStyle();
			wraptextStyle.setWrapText(true);

			int lastHeaderColNum = writingHeaderInExcel(sheet, workbook);

			// Getting all Project Count
			totalProjectCount = AllProjectCount.getAllProjectCount();

			// Cursor
			int index = 0;
			int projectCount = oneTimeProjectCount;
			// Setting cursor position and number of rows at a time
			cursor.setPosition(index);
			cursor.setNumRows(projectCount);
			int trackCount = 1;

			// Loop for getting patch of project based on oneTimeProejectCount
			while (index < totalProjectCount) {

				// This service will fetch List of Projects based on cursor
				BusObjectIterator<GenerateExcelORCSVFile> tempProjectData = GenerateExcelORCSVFile
						.getAllProjects(cursor);
				// Out of oneTimeProjectCount getting 100 projects at a time
				int tempIndex = 0;
				int dataCount = 100;
				int tempProjectCount = totalProjectCount >= (trackCount * projectCount) ? (projectCount)
						: (totalProjectCount - ((trackCount - 1) * projectCount));
				// Loop for getting 100 projects at a time
				while (tempIndex < tempProjectCount) {
					Map<Integer, GenerateExcelORCSVFile> allProjectData = new HashMap<>();
					Map<Integer, ArrayList<GovernanceMileStone>> allMileStoneMap = new HashMap<>();
					Map<Integer, ArrayList<Tasks>> taskMap = new HashMap<>();
					ArrayList<Integer> requestIDList = new ArrayList<>();
					int tempCount = 0;
					// Getting ID's of that 100 Projects by this Loop
					while (tempProjectData.hasMoreElements() && tempCount < dataCount) {
						GenerateExcelORCSVFile projectObject = tempProjectData.nextElement();
						requestIDList.add(projectObject.getIntProperty(requestIDEnum));
						// Storing Project with RequestId as Key with Class Object as Value in Map based
						// on oneTimeProjectCount projects
						allProjectData.put(projectObject.getIntProperty(requestIDEnum), projectObject);
						tempCount = tempCount + 1;
					}
					// Changing List of RequestID to String and then into Range of RequestID
					// (Purpose Query works with IN for Range)
					String oneTimeProjectNoRange = requestIDList.toString().replace("[", "(").replace("]", ")");
					// Getting All Governance MileStones related to that 100 Project RequestID
					BusObjectIterator<GovernanceMileStone> allGovMilestone = GovernanceMileStone
							.GetAllGovernanceMileStone(oneTimeProjectNoRange);
					// Iterating over List of GOV MileStone and store in Map with ReuestID as Key
					while (allGovMilestone.hasMoreElements()) {
						ArrayList<GovernanceMileStone> mileStoneArrayList = new ArrayList<>();
						GovernanceMileStone govMileStone = allGovMilestone.nextElement();
						int govRequestID = govMileStone.getIntProperty(requestIDEnum);
						if (allMileStoneMap.containsKey(govRequestID)) {
							mileStoneArrayList = allMileStoneMap.get(govRequestID);
							mileStoneArrayList.add(govMileStone);
							allMileStoneMap.put(govRequestID, mileStoneArrayList);
						} else {
							mileStoneArrayList.add(govMileStone);
							allMileStoneMap.put(govRequestID, mileStoneArrayList);
						}
					}
					// Getting All Tasks related to that 100 Project RequestID
					BusObjectIterator<Tasks> allTasks = Tasks.getAllTasks(oneTimeProjectNoRange);
					// Iterating over List of Task and store in Map with ReuestID as Key
					while (allTasks.hasMoreElements()) {
						ArrayList<Tasks> taskList = new ArrayList<>();
						Tasks tasks = allTasks.nextElement();
						int taskRequestID = tasks.getIntProperty(requestIDEnum);
						if (taskMap.containsKey(taskRequestID)) {
							taskList = taskMap.get(taskRequestID);
							taskList.add(tasks);
							taskMap.put(taskRequestID, taskList);
						} else {
							taskList.add(tasks);
							taskMap.put(taskRequestID, taskList);
						}
					}
					logger.error("Calling Function for Excel write");
					writingExcel(allProjectData, allMileStoneMap, taskMap, sheet, workbook, lastHeaderColNum);
					logger.error("Excel Writing done");
					tempIndex = tempIndex + dataCount;
				}

				index = index + projectCount;
				cursor.setPosition(index);
				trackCount = trackCount + 1;
			}
			fileCheckPath = filePath + fileName + ".xlsx";
			File newFile = new File(fileCheckPath);
			FileOutputStream outputStream = new FileOutputStream(newFile);
			logger.error("File Created");
			workbook.write(outputStream);
			// Calling MPM_Export_Data BPM by using triggerMPMExportData function
			MPMExportData.triggerMPMExportData(fileCheckPath, fileName, id);
			logger.error("Excel Created");

		} catch (Exception e) {
			logger.error("Task Integration Service Failed " + e);

		}
		return fileCheckPath;
	}
    
	/**
	 * @author AvinashRavat
	 * @param sheet
	 * @param workbook
	 * @return This Service will write columns Headers in Excel
	 */
	public static int writingHeaderInExcel(XSSFSheet sheet, XSSFWorkbook workbook) {
		// Writing Header Fields name
		int headerColNum = 0;
		Row headerRow = sheet.createRow(0);
		for (EnumColumnMapper columns : EnumColumnMapper.values()) {
			String colName=columns.toString();
			if(colName.contains("Date")|| colName.contains("HBCRPEMSEB")) {
				sheet.setColumnWidth(headerColNum, 25 * 256);
			}
			Cell cell = headerRow.createCell(headerColNum++);
			cell.setCellValue(columns.toString());
		}
		for (int i = 0; i <= 4; i++) {
			for (EnumGovernanceMileStoneMapper columns : EnumGovernanceMileStoneMapper.values()) {
				String colName=columns.toString();
				if(colName.contains("Date")) {
					sheet.setColumnWidth(headerColNum, 25 * 256);
				}
				Cell cell = headerRow.createCell(headerColNum++);
				cell.setCellValue(columns.toString() + i);
			}
		}
		for (int i = 2; i <= 42; i++) {
			for (EnumTaskColumnMapper columns : EnumTaskColumnMapper.values()) {
				String colName=columns.toString();
				if(colName.contains("Date")) {
					sheet.setColumnWidth(headerColNum, 25 * 256);
				}
				Cell cell = headerRow.createCell(headerColNum++);
				cell.setCellValue(columns.toString() + i);
			}
			if (i == 13) {
				for (EnumTaskColumnMapper columns : EnumTaskColumnMapper.values()) {
					Cell cell = headerRow.createCell(headerColNum++);
					cell.setCellValue(columns.toString() + "13A");
				}
			}
		}
		Cell divisionCell = headerRow.createCell(headerColNum);
		divisionCell.setCellValue(divisionEnum);
		logger.error("Header writing done ");
		return headerColNum;
	}
	/**
	 * @author AvinashRavat
	 * @param allProjectData
	 * @param allMileStoneMap
	 * @param taskMap
	 * @param sheet
	 * @param workbook
	 * @param lastHeaderColNum
	 * @return This Service will write Projects and MileStone related columns in Excel
	 */
	public static void writingExcel(Map<Integer, GenerateExcelORCSVFile> allProjectData,
			Map<Integer, ArrayList<GovernanceMileStone>> allMileStoneMap, Map<Integer, ArrayList<Tasks>> taskMap,
			XSSFSheet sheet, XSSFWorkbook workbook, int lastHeaderColNum) {
		
		try {
			// Writing Projects stored in allProjectData
			int rowNum = sheet.getLastRowNum() + 1;
			for (int projectKey : allProjectData.keySet()) {

				Row row = sheet.createRow(rowNum++);
				int colNum = 0;
				GenerateExcelORCSVFile project = allProjectData.get(projectKey);
				for (EnumColumnMapper columns : EnumColumnMapper.values()) {
					Cell cell = row.createCell(colNum++);

					String value = project.getStringProperty(columns.toString());
					
					

					if (Util.isNumeric(value)) {
						long intVal = project.getLongProperty(columns.toString());
						cell.setCellValue(intVal);
					}
					writingInCellWithDataType(cell,value,sheet,workbook);
					
				}
				// Storing division value
				divisionValue = project.getStringProperty(divisionEnum);
				if (allMileStoneMap.size() != 0) {
					ArrayList<GovernanceMileStone> governanceMileStoneList = allMileStoneMap.get(projectKey);
					int currIndexOfMileStone = 0;
					if (governanceMileStoneList != null) {
						for (GovernanceMileStone govMileStone : governanceMileStoneList) {
							String stageName = govMileStone.getStringProperty(stage);
							int stageCol = Integer.parseInt(stageName.replaceAll("[\\D]", ""));

							for (EnumGovernanceMileStoneMapper columns : EnumGovernanceMileStoneMapper.values()) {
								Cell cell = row.createCell(colNum++);

								String value = govMileStone.getStringProperty(columns.toString());

								if (Util.isNumeric(value)) {
									long intVal = govMileStone.getLongProperty(columns.toString());
									cell.setCellValue(intVal);
								} 
								writingInCellWithDataType(cell,value,sheet,workbook);

							}
							currIndexOfMileStone = stageCol + 1;
						}
					}
					// Adding Space if milestone is not present for any Specific Projects
					if (currIndexOfMileStone < 5) {
						int itrSpace = 5 - currIndexOfMileStone;
						for (int i = 0; i < itrSpace; i++) {
							for (EnumGovernanceMileStoneMapper columns : EnumGovernanceMileStoneMapper.values()) {
								Cell cell = row.createCell(colNum++);
								cell.setCellValue(" ");
							}
						}
					}
				}
        
				writingProjectTaskExcel(projectKey, taskMap, sheet, workbook, row, colNum, lastHeaderColNum);
			}
			
		} catch (Exception e) {
			logger.error("Excel Writing Failed " + e);

		}
	}

	/**
	 * @author AvinashRavat
	 * @param projectKey
	 * @param taskMap
	 * @param sheet
	 * @param workbook
	 * @param row
	 * @param colNum
	 * @param lastHeaderColNum
	 * @return This Service will write Projects Related Tasks columns in Excel
	 */
	public static void writingProjectTaskExcel(int projectKey, Map<Integer, ArrayList<Tasks>> taskMap, XSSFSheet sheet,
			XSSFWorkbook workbook, Row row, int colNum, int lastHeaderColNum) {
		try {
			int currentTaskIndex = 2;
			int taskCol = 0;
			boolean isTask13Present = false;
			boolean isTask13APresent = false;
			ArrayList<Tasks> taskMapList = taskMap.get(projectKey);
			if (taskMapList != null) {
				for (Tasks taskObject : taskMapList) {
					// Getting current task index from Task Name
					String taskName = taskObject.getStringProperty(taskNameEnum);
					taskCol = Integer.parseInt(taskName.replaceAll("[\\D]", ""));
					int itrCount = 0;

					if (TasksEnum.taskNameList.contains(taskName)) {

						// task-2 to task 42
						if (taskCol > 13 && currentTaskIndex < 13) {
							itrCount = taskCol - currentTaskIndex + 1;
						}
						// task 2 to task 13A without task13
						else if (taskCol == 13 && currentTaskIndex <= 13 && taskName.equals(task13A)) {
							itrCount = taskCol - currentTaskIndex + 1;
						}
						// task 13 to task42 with task13A
						else if (taskCol >= 14 && currentTaskIndex == 14 && isTask13APresent) {
							itrCount = taskCol - currentTaskIndex;
							isTask13APresent = false;
						}
						// task 13 to task42 without task13A
						else if (taskCol >= 14 && currentTaskIndex == 14 && isTask13Present) {
							itrCount = taskCol - currentTaskIndex + 1;
							isTask13Present = false;
						}

						else {
							itrCount = taskCol - currentTaskIndex;
						}

						if (itrCount > 0) {
							for (int initItr = 0; initItr < itrCount; initItr++) {
								for (EnumTaskColumnMapper columns : EnumTaskColumnMapper.values()) {
									Cell cell = row.createCell(colNum++);
									cell.setCellValue(" ");
								}
							}
						}

						for (EnumTaskColumnMapper columns : EnumTaskColumnMapper.values()) {
							Cell cell = row.createCell(colNum++);
							String value = taskObject.getStringProperty(columns.toString());

							if (Util.isNumeric(value)) {
								long intVal = taskObject.getLongProperty(columns.toString());
								cell.setCellValue(intVal);
							} 
							writingInCellWithDataType(cell,value,sheet,workbook);
						}

						if (taskName.equals(task13)) {
							isTask13Present = true;
						}
						if (taskName.equals(task13A)) {
							isTask13APresent = true;
						}
						currentTaskIndex = taskCol + 1;

					}

				}
			}
			Cell cell = row.createCell(lastHeaderColNum);
			cell.setCellValue(divisionValue);
		} catch (Exception e) {
			logger.error("Task Writing Failed " + e);

		}
	}
	/**
	 * @author AvinashRavat
	 * @param projectKey
	 * @param taskMap
	 * @param sheet
	 * @param workbook
	 * @param row
	 * @param colNum
	 * @param lastHeaderColNum
	 * @return This Service will write Projects Related Tasks columns in Excel
	 */
    private static void writingInCellWithDataType(Cell cell, String value, XSSFSheet sheet, XSSFWorkbook workbook) throws ParseException {
   	 if (Util.isDouble(value.toString())) {
				
				Double doubleValue = new Double(value.toString());
				String formatVal = String.format("%.4f", doubleValue);
				cell.setCellValue(new Double(formatVal));
			} else if (Util.isValidDate(value.toString())) {

				
				SimpleDateFormat datetemp = new SimpleDateFormat("dd/MM/yyyy");
				Date cellValue = datetemp.parse(value.toString());
				cell.setCellValue(cellValue);
				CellStyle dateCellStyle = workbook.createCellStyle();
				short df = workbook.createDataFormat().getFormat("dd/MM/yyyy");
				dateCellStyle.setDataFormat(df);
				cell.setCellStyle(dateCellStyle);
			} else {
				
				cell.setCellValue(value);
			}
	}

	public void onInsert() {
	}

	public void onUpdate() {
	}

	public void onDelete() {
	}

}
